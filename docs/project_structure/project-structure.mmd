%% Swanytello - Project structure and architecture
%% Render at https://mermaid.live or in any Mermaid-compatible viewer

%% --- 1. Monolith architecture (high-level) ---
flowchart TB
  subgraph external [External]
    Frontends[Frontends]
    Systems[External systems]
    Users[Users]
  end

  subgraph monolith [Swanytello monolith]
    subgraph api [REST API]
      Fastify[Fastify]
      Routes[Routes / Controllers / Services]
      Fastify --> Routes
    end

    subgraph rag [RAG]
      RAGLogic[RAG + LangChain]
    end

    subgraph channels [Channels]
      WhatsApp[WhatsApp]
      Discord[Discord]
    end

    subgraph etl [ETL]
      Extract[Extract]
      Transform[Transform]
      Load[Load]
      Process[Process / Scheduler]
      Extract --> Transform --> Load
      Process --> Extract
    end

    subgraph db_ops [Database Operations]
      Models[Models / Prisma]
      Types[Types / Schemas]
    end

    subgraph shared [Shared]
      Log[log]
      Types[types]
      Utils[utils]
    end
  end

  Frontends --> api
  Systems --> api
  Users --> channels
  channels --> api
  channels --> rag
  etl --> rag
  api --> db_ops
  etl --> db_ops
  rag -.->|tool functions| api
  api --> Log
  rag --> Log
  channels --> Log
  etl --> Log
  db_ops --> Log

%% --- 2. Folder structure (tree-style) ---
flowchart TB
  subgraph root [Project root]
    guardrails[guardrails/]
    prisma[prisma/]
    docker[docker/]
    tests[tests/]
    config[prisma.config.ts, package.json, vitest.config.ts]
  end

  subgraph src_content [src/]
    server[server.ts]
    api[api/]
    rag[rag/]
    channels[channels/]
    etl[etl/]
    db_ops[db_operations/]
    log[log/]
    types[types/]
    utils[utils/]
  end

  subgraph api_content [api/]
    routes[routes]
    controllers[controllers]
    services[services]
    schemas[schemas]
    middleware[middleware]
    fastify[fastifyInstance.ts]
  end

  subgraph rag_content [rag/]
    rag_index[index.ts]
    rag_tools[tools/]
    rag_chains[chains/]
    rag_llms[llms/]
  end

  subgraph channels_content [channels/]
    whatsapp[whatsapp/]
    discord[discord/]
  end

  subgraph db_ops_content [db_operations/]
    db_ops_index[index.ts]
    models[models/]
    db_types[db_types/]
    prisma_instance[prismaInstance.ts]
  end

  subgraph etl_content [etl/]
    etl_index[index.ts]
    extract_folder[extract/]
    transform_folder[transform/]
    load_folder[load/]
    process_folder[process/]
  end

  subgraph utils_content [utils/]
    utils_index[index.ts]
    utils_db_ping[dbPing.ts]
    utils_rag_ping[ragPing.ts]
    utils_file_storage[fileStorage.ts]
  end

  subgraph docker_content [docker/]
    compose[docker-compose.yml]
    dockerignore[.dockerignore]
    postgres_docker[postgres_docker/]
  end

  subgraph tests_content [tests/]
    tests_setup[setup.ts]
    tests_helpers[helpers/]
    tests_api[api/]
    tests_db_ops[db_operations/]
  end

  root --> guardrails
  root --> prisma
  root --> docker
  root --> tests
  root --> config
  root --> src_content
  api --> api_content
  rag --> rag_content
  channels --> channels_content
  db_ops --> db_ops_content
  etl --> etl_content
  utils --> utils_content
  docker --> docker_content
  tests --> tests_content

%% --- 3. RAG request flow (POST /api/rag/test or /api/rag/chat) ---
sequenceDiagram
  participant Client
  participant Route as rag.routes
  participant Controller as rag.controller
  participant Service as rag.service
  participant Chain as chat.chain
  participant LLM as llms (Ollama Cloud / OpenAI)

  Client->>Route: POST /api/rag/test or /api/rag/chat (message [+ PDF])
  Route->>Controller: testRag(body) or chatRag(payload, userId)
  Controller->>Service: runRagChat(body) or runRagChatWithPdf(payload)
  Service->>Service: Parse body / multipart
  Service->>Chain: runChatChain(message [, attachment])
  Chain->>LLM: getChatModel().invoke(message)
  LLM->>Chain: AIMessage content
  Chain->>Service: reply string
  Service->>Controller: { reply, timestamp }
  Controller->>Route: result
  Route->>Client: 200 + { reply, timestamp }

%% --- 4. ETL process (LinkedIn jobs â†’ open_position) ---
flowchart LR
  subgraph etl_run [ETL run]
    E_Extract[extract: findLinkedInJobs]
    E_Transform[transform: linkedinToOpenPosition]
    E_Load[load: loadOpenPositions]
    E_Extract --> E_Transform --> E_Load
  end
  E_Load --> DB[(open_position table)]
  Scheduler[startEtlScheduler] --> E_Extract
  Note[On startup + every 12h]

%% --- 5. Startup checks (DB + RAG) and ETL scheduler ---
sequenceDiagram
  participant Server as server.ts
  participant Dotenv as dotenv
  participant DBPing as utils/dbPing
  participant RAGPing as utils/ragPing
  participant ETL as etl/process

  Server->>Dotenv: config(.env)
  Server->>DBPing: displayDatabaseStatus()
  DBPing->>DBPing: checkDatabaseStatus()
  Server->>RAGPing: displayRagStatus()
  RAGPing->>RAGPing: checkRagStatus() (Ollama Cloud / OpenAI)
  Server->>Server: Register routes, listen
  Server->>ETL: startEtlScheduler()
  ETL->>ETL: run once (startup), then every 12h

%% --- 6. WhatsApp send last 12h (POST /api/whatsapp/send-open-positions-last-12h) ---
sequenceDiagram
  participant Client
  participant Route as whatsapp.routes
  participant DB as db_operations
  participant Channel as channels/whatsapp
  participant Baileys as Baileys socket

  Client->>Route: POST /api/whatsapp/send-open-positions-last-12h (body.to optional)
  Route->>Route: toJid(body.to ?? WHATSAPP_TARGET_JID)
  Route->>DB: getOpenPositionsCreatedInLastHours(12)
  DB->>Route: OpenPosition[]
  Route->>Channel: sendPositionsListToWhatsApp(jid, positions, "Last 12h open positions (DB)")
  Channel->>Channel: format list + header
  Channel->>Baileys: sendTextMessage(jid, text)
  Baileys->>Channel: ok
  Channel->>Route: { sent: true, message }
  Route->>Client: 200 { ok, message }
